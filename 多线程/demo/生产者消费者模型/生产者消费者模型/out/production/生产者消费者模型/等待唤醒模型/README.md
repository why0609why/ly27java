# demo
这个demo是一个等待唤醒模型例子。

有两个线程，一个是设置学生类的线程，一个是获取学生类的线程，这两个线程进行通信，上的锁的学生对象那个锁。
打印结果是两个学生的信息相互交替。会有一个flag标志表示在赋值或者打印时能否赋值或者打印，如果在赋值时发现不能赋值，就把set自己wait掉，同理打印也是一样。每个线程进行操作完就将调用notify，唤醒另一个线程。

demo主要流程：一开始flag的值时false，根据两个线程的内部代码，不管是谁先抢夺到执行权，都会先执行set线程的操作，因为如果是get线程抢夺到执行权的话也是会进入wait，如果是set先抢夺到执行权的话自然就是执行set线程的操作，set线程赋值完一个学生的信息之后，会将flag置反，不管get线程是不是wait中的，都会notify()get线程，此时两个线程再次抢夺cpu执行权，此时和刚才一样，因为flag的原因，不管是set和get谁抢夺到执行权，执行的操作都是get线程内的操作，同样当get操作执行完毕后，flag又会置反，以至于下次会让set线程的操作在下一次抢夺时得到执行，如此循环。


一个很好线程等待唤醒模型。掌握执行流程对于多线程的理解很有帮助。