# 针对上面基础买票的那个bug
可以进行分析一下

- 首先使用了多线程
- 是否有共享数据
- 是否有多条语句操作共享数据

那么这三个问题中第一个和第二个都没办法避免，只有第三个问题可以下手。
所以这里采用锁，每次使用共享数据的时候都上一层锁。在一个线程访问共享数据的时候，对共享数据进行上锁，上锁之后其他线程不能访问带锁的共享数据。所以这里把所有有关于票的操作都放到锁里面，比如票的判断、票的输出、票的减减。这样能保证有关于票的操作不被线程污染。

这里锁用的对象还是随便new了一个Object，而且三个线程的锁用的都是一个锁。

还有一个问题，如果while写的是这样的话，虽然也能达到锁共享数据的效果，但是这样会把while循环锁起来，当一个线程上了锁以后，就会一直在while循环里执行代码。
```java
synchronized (object) {
    while (ticket>0) {
        //把有关于票的操作全都锁起来
        System.out.println(Thread.currentThread().getName()+"卖出了第"+ticket+
                "张票");
        ticket--;
        }
}
```